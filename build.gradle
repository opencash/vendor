def localIvyRepoUri = uri("$rootProject.projectDir/../local_ivy_repo")
if (System.env.IVY_REPO_DIR) { localIvyRepoUri = System.env.IVY_REPO_DIR }

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    // https://github.com/michel-kraemer/gradle-download-task
    classpath 'de.undercouch:gradle-download-task:0.4'
  }
}

import de.undercouch.gradle.tasks.download.Download
import org.gradle.api.publish.ivy.internal.dependency.DefaultIvyDependency

ext.currentPlatform = getCurrentPlatform()

project(':poco') {
    version = '1.5.2'

    ext {
        archiveName = "poco-${version}-release.tar.gz"
        vendorUrl = "https://github.com/pocoproject/poco/archive/$archiveName"
        explodedDirName = "poco-poco-${version}-release"
        targetPlatforms = ['osx-x86_64', 'linux-amd64', 'android-arm']

        tripletForPlatform = [
            'osx-x86_64': 'Darwin-clang-libc++',
            'linux-amd64': 'x86_64-pc-linux',
            'android-arm': 'Android',
            ]

        configureCommandLine = [
            "./configure",
            "--config=${-> tripletForPlatform[platform]}",
            "--prefix=${-> platformInstallDir}",
            "--no-tests",
            "--no-samples",
            "--static",
            ]

        assembleCommandLine = [
            'make',
            '-f',
            'Makefile',
            '-f',
            'Makefile-custom',
            'my_static_release',
            'my_install',
            ]
    }
}

project(':libodb') {
    version = '2.3.0'

    ext {
        archiveName = "libodb-${version}.zip"
        vendorUrl = "http://www.codesynthesis.com/download/odb/2.3/$archiveName"
        explodedDirName = "libodb-${version}"
        targetPlatforms = ['osx-x86_64', 'linux-amd64', 'android-arm']

        tripletForPlatform = [
            'osx-x86_64': 'x86_64-apple-darwin13.0.0',
            'linux-amd64': 'x86_64-pc-linux',
            'android-arm': 'arm-linux-androideabi',
            ]

        cxxflagsForPlatform = [
            'osx-x86_64': '-stdlib=libc++',
            'linux-amd64': '',
            'android-arm': '',
            ]

        configureCommandLine = [
            "./configure",
            "--prefix=${-> platformInstallDir}",
            "--host=${-> tripletForPlatform[platform]}",
            "--build=${-> currentPlatform}",
            "--disable-shared",
            "--enable-static",
            "--disable-threads",
            "CXXFLAGS=${-> cxxflagsForPlatform[platform]}",
            ]
    }
}

project(':libodb-sqlite') {
    version = '2.3.0'

    ext {
        archiveName = "libodb-sqlite-${version}.zip"
        vendorUrl = "http://www.codesynthesis.com/download/odb/2.3/$archiveName"
        explodedDirName = "libodb-sqlite-${version}"
        targetPlatforms = ['osx-x86_64', 'linux-amd64', 'android-arm']

        narDependencies = [
            'all':
                [[group: "com.github.opencash.vendor", name: "libodb", version: "$version", configuration: "${-> platform}"]],
            'linux-amd64':
                [[group: "com.github.opencash.vendor", name: "sqlite3", version: "3080200", configuration: "${-> platform}"]],
            'android-arm':
                [[group: "com.github.opencash.vendor", name: "sqlite3", version: "3080200", configuration: "${-> platform}"]],
            ]

        tripletForPlatform = [
            'osx-x86_64': 'x86_64-apple-darwin13.0.0',
            'linux-amd64': 'x86_64-pc-linux',
            'android-arm': 'arm-linux-androideabi',
            ]

        cxxflagsForPlatform = [
            'osx-x86_64': '-stdlib=libc++',
            'linux-amd64': '',
            'android-arm': '',
            ]

        configureCommandLine = [
            "./configure",
            "--prefix=${-> platformInstallDir}",
            "--host=${-> tripletForPlatform[platform]}",
            "--build=${-> currentPlatform}",
            "--disable-shared",
            "--enable-static",
            "--disable-threads",
            "LDFLAGS=-L${-> platformDepsDir}/lib",
            "CPPFLAGS=-I${-> platformDepsDir}/include",
            "CXXFLAGS=${-> cxxflagsForPlatform[platform]}",
            ]
    }
}

project(':sqlite3') {
    version = '3080200'

    ext {
        archiveName = "sqlite-autoconf-${version}.tar.gz"
        vendorUrl = "http://www.sqlite.org/2013/$archiveName"
        explodedDirName = "sqlite-autoconf-${version}"
        targetPlatforms = ['linux-amd64', 'android-arm']

        tripletForPlatform = [
            'linux-amd64': 'x86_64-pc-linux',
            'android-arm': 'arm-linux-androideabi',
            ]

        configureCommandLine = [
            "./configure",
            "--prefix=${-> platformInstallDir}",
            "--host=${-> tripletForPlatform[platform]}",
            "--build=${-> currentPlatform}",
            "--disable-shared",
            "--enable-static",
            "CFLAGS=-DSQLITE_ENABLE_UNLOCK_NOTIFY=1",
            ]
    }
}

project(':gtest') {
    version = '1.7.0'

    ext {
        archiveName = "gtest-${version}.zip"
        vendorUrl = "https://googletest.googlecode.com/files/$archiveName"
        explodedDirName = "gtest-${version}"
        targetPlatforms = ['osx-x86_64', 'linux-amd64', 'android-arm']

        tripletForPlatform = [
            'osx-x86_64': 'x86_64-apple-darwin13.0.0',
            'linux-amd64': 'x86_64-pc-linux',
            'android-arm': 'arm-linux-androideabi',
            ]

        cxxflagsForPlatform = [
            'osx-x86_64': '-stdlib=libc++',
            'linux-amd64': '',
            'android-arm': '',
            ]

        configureCommandLine = [
            "./configure",
            "--prefix=${-> platformInstallDir}",
            "--host=${-> tripletForPlatform[platform]}",
            "--build=${-> currentPlatform}",
            "--disable-shared",
            "--enable-static",
            "CXXFLAGS=${-> cxxflagsForPlatform[platform]}",
            ]

        assembleCommandLine = [
            'make',
            'all',
            'install-libLTLIBRARIES',
            'install-pkgincludeHEADERS',
            'install-pkginclude_internalHEADERS',
            ]
    }
}

project(':gmock') {
    version = '1.7.0'

    ext {
        archiveName = "gmock-${version}.zip"
        vendorUrl = "https://googlemock.googlecode.com/files/$archiveName"
        explodedDirName = "gmock-${version}"
        targetPlatforms = ['osx-x86_64', 'linux-amd64', 'android-arm']

        tripletForPlatform = [
            'osx-x86_64': 'x86_64-apple-darwin13.0.0',
            'linux-amd64': 'x86_64-pc-linux',
            'android-arm': 'arm-linux-androideabi',
            ]

        cxxflagsForPlatform = [
            'osx-x86_64': '-stdlib=libc++',
            'linux-amd64': '',
            'android-arm': '',
            ]

        configureCommandLine = [
            "./configure",
            "--prefix=${-> platformInstallDir}",
            "--host=${-> tripletForPlatform[platform]}",
            "--build=${-> currentPlatform}",
            "--disable-shared",
            "--enable-static",
            "CXXFLAGS=${-> cxxflagsForPlatform[platform]}",
            ]

        assembleCommandLine = [
            'make',
            'all',
            'install-libLTLIBRARIES',
            'install-pkgincludeHEADERS',
            'install-pkginclude_internalHEADERS',
            ]
    }
}

// apply the following to all subprojects in settings.gradle
// using the values specified above
subprojects {
    apply plugin: 'cpp'
    apply plugin: 'ivy-publish'

    group = 'com.github.opencash.vendor'

    repositories {
        ivy {
            url localIvyRepoUri
        }
    }

    publishing {
        repositories {
            ivy {
                url localIvyRepoUri
            }
        }
    }

    task testResolveDependencies << {
        println "Testing dependency resolution"
        configurations.each { conf ->
            println "=> $conf:"
            conf.files.each { println "   -> $it" }
        }
    }

    task download(type: Download) {
        outputs.files file("$buildDir/$archiveName")
        src vendorUrl
        dest buildDir
        overwrite false
    }

    targetPlatforms.each {
        ext.platform = it
        ext.platformDir = file("$buildDir/$platform")
        ext.platformSrcDir = file("$platformDir/$explodedDirName")
        ext.platformInstallDir = file("$platformDir/install")
        ext.platformDepsDir = file("$platformDir/deps")

        def platformConf = configurations.create "compile-$platform"
        if (project.hasProperty('narDependencies')) {
            narDependencies['all'].each {
                dependencies.add "compile-$platform", it
            }
            narDependencies[platform].each {
                dependencies.add "compile-$platform", it
            }
        }

        task("unarchive-$platform", dependsOn: download) {
            inputs.files download.outputs.files.singleFile
            // Bind scope of platformSrcDir
            def platSrcDir = platformSrcDir
            outputs.upToDateWhen { platSrcDir.exists() }

            // A task of type Copy would mess with outputs field and hence
            // confuse upToDateWhen, so we use a separate closure. By doing
            // that, platformDir gets evaluated at runtime and usually doesn't
            // correspond to the value of platform anymore. We bind the scope
            // of platformDir through use of an intermediate variable
            def destDir = platformDir
            doLast {
                copy {
                    def f = download.outputs.files.singleFile
                    def t = f.name.endsWith('.zip') ?
                        zipTree(f) : tarTree(f)

                    from t
                    into destDir
                }
            }
        }

        task("patch-$platform", dependsOn: "unarchive-$platform") {
            outputs.files file("$platformSrcDir/.patched")

            fileTree(file("$projectDir/patches")).include('**/*.patch').each { File file ->
                // Bind scope of platformSrcDir
                def destDir = platformSrcDir
                doLast {
                    exec {
                        logging.captureStandardOutput LogLevel.INFO
                        logging.captureStandardError LogLevel.INFO

                        workingDir destDir
                        commandLine 'patch', '--strip=1', '--batch',
                            '--forward', "--input=$file", '--verbose'
                    }
                }
                doLast {
                    new File("$destDir/.patched").createNewFile()
                }
            }
        }

        task("retrieveDependencies-$platform", type: Copy) {
            from platformConf
            into platformDepsDir

            platformConf.incoming.afterResolve { ResolvableDependencies incoming ->
                incoming.files.each { File file ->
                    if (file.name.endsWith(".nar")) {
                        from zipTree(file)
                    }
                }
            }
        }

        task("configure-$platform", type: Exec,
                dependsOn: ["unarchive-$platform",
                    "patch-$platform",
                    "retrieveDependencies-$platform"])
        {
            // Evaluate lazy GString to interpolate current
            // project values
            def cmdLine = configureCommandLine*.toString()

            logging.captureStandardOutput LogLevel.INFO
            logging.captureStandardError LogLevel.INFO

            workingDir platformSrcDir
            commandLine cmdLine

            // Cannot use the following since some projects already come
            // with a Makefile. Couldn't find a consistent choice across
            // projects, thus commenting out. The downside is that the
            // configure step will run on every build, which is acceptable
            // since builds run rarely (only on upstream changes).
            // outputs.files file("$platformSrcDir/Makefile")
        }

        task("assemble-$platform", type: Exec,
                dependsOn: "configure-$platform")
        {
            logging.captureStandardOutput LogLevel.INFO
            logging.captureStandardError LogLevel.INFO

            workingDir platformSrcDir

            if (project.hasProperty('assembleCommandLine')) {
                commandLine assembleCommandLine
            } else {
                commandLine 'make', 'all', 'install'
            }
        }

        def platformPackage = task("package-$platform", type: Zip) {
            dependsOn "assemble-$platform"
            from platformInstallDir

            baseName project.name
            version version
            classifier platform
            extension 'nar'
        }

        def boundPlatform = platform
        publishing {
            publications {
                def pub = findByName(project.name)
                if (pub == null) {
                    pub = create(project.name, IvyPublication)
                }

                def pubConf = pub.configurations.maybeCreate(boundPlatform)
                pub.artifact(platformPackage) {
                   conf = pubConf.name
                }

                platformConf.allDependencies.withType(ModuleDependency).each { dep ->
                    def ivyDep = new DefaultIvyDependency(
                        dep.group, dep.name, dep.version,
                        "${pubConf.name}->${dep.configuration}", dep.artifacts)
                    pub.dependencies.add ivyDep
                }
            }
        }
    }

}

def getCurrentPlatform() {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'gcc', '-dumpmachine'
        standardOutput = stdout
    }
    stdout.toString().trim()
}
