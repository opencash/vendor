def localIvyRepoUri = uri("$rootProject.projectDir/../ivy_repo")
if (System.env.IVY_REPO_DIR) { localIvyRepoUri = System.env.IVY_REPO_DIR }

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    // https://github.com/michel-kraemer/gradle-download-task
    classpath 'de.undercouch:gradle-download-task:0.4'
  }
}

import de.undercouch.gradle.tasks.download.Download

ext.currentPlatform = getCurrentPlatform()

project(':poco') {
    version = '1.5.2'

    ext {
        archiveName = "poco-${version}-release.tar.gz"
        vendorUrl = "https://github.com/pocoproject/poco/archive/$archiveName"
        explodedDirName = "poco-poco-${version}-release"
        targetPlatforms = ['osx-x86_64', 'linux-amd64', 'android-arm']

        configForPlatform = [
            'osx-x86_64': '',
            'linux-amd64': '',
            'android-arm': 'Android',
            ]

        configureCommandLine = [
            "./configure",
            "--config=${-> configForPlatform[platform]}",
            "--prefix=${-> platformInstallDir}",
            "--no-tests",
            "--no-samples",
            "--static",
            ]

        assembleCommandLine = [
            'make',
            '-f',
            'Makefile',
            '-f',
            'Makefile-custom',
            'my_static_release',
            'my_install',
            ]
    }
}

project(':libodb') {
    version = '2.3.0'

    ext {
        archiveName = "libodb-${version}.zip"
        vendorUrl = "http://www.codesynthesis.com/download/odb/2.3/$archiveName"
        explodedDirName = "libodb-${version}"
        targetPlatforms = ['osx-x86_64', 'linux-amd64', 'android-arm']

        configForPlatform = [
            'osx-x86_64': 'x86_64-apple-darwin13.0.0',
            'linux-amd64': 'x86_64-pc-linux',
            'android-arm': 'arm-linux-androideabi',
            ]

        configureCommandLine = [
            "./configure",
            "--prefix=${-> platformInstallDir}",
            "--host=${-> configForPlatform[platform]}",
            "--build=${-> currentPlatform}",
            "--disable-shared",
            "--enable-static",
            "--disable-threads",
            ]
    }
}

project(':libodb-sqlite') {
    version = '2.3.0'

    ext {
        archiveName = "libodb-sqlite-${version}.zip"
        vendorUrl = "http://www.codesynthesis.com/download/odb/2.3/$archiveName"
        explodedDirName = "libodb-sqlite-${version}"
        targetPlatforms = ['osx-x86_64', 'linux-amd64', 'android-arm']

        narDependencies = [
            'all':
                ["com.github.opencash.vendor:libodb:$version:${-> platform}@nar"],
            'linux-amd64':
                ["com.github.opencash.vendor:sqlite3:3080200:${-> platform}@nar"],
            'android-arm':
                ["com.github.opencash.vendor:sqlite3:3080200:${-> platform}@nar"],
            ]

        configForPlatform = [
            'osx-x86_64': 'x86_64-apple-darwin13.0.0',
            'linux-amd64': 'x86_64-pc-linux',
            'android-arm': 'arm-linux-androideabi',
            ]

        configureCommandLine = [
            "./configure",
            "--prefix=${-> platformInstallDir}",
            "--host=${-> configForPlatform[platform]}",
            "--build=${-> currentPlatform}",
            "--disable-shared",
            "--enable-static",
            "--disable-threads",
            "LDFLAGS=-L${-> platformDepsDir}/lib",
            "CPPFLAGS=-I${-> platformDepsDir}/include",
            ]
    }
}

project(':sqlite3') {
    version = '3080200'

    ext {
        archiveName = "sqlite-autoconf-${version}.tar.gz"
        vendorUrl = "http://www.sqlite.org/2013/$archiveName"
        explodedDirName = "sqlite-autoconf-${version}"
        targetPlatforms = ['linux-amd64', 'android-arm']

        configForPlatform = [
            'linux-amd64': 'x86_64-pc-linux',
            'android-arm': 'arm-linux-androideabi',
            ]

        configureCommandLine = [
            "./configure",
            "--prefix=${-> platformInstallDir}",
            "--host=${-> configForPlatform[platform]}",
            "--build=${-> currentPlatform}",
            "--disable-shared",
            "--enable-static",
            "CFLAGS=-DSQLITE_ENABLE_UNLOCK_NOTIFY=1",
            ]
    }
}

project(':gtest') {
    version = '1.7.0'

    ext {
        archiveName = "gtest-${version}.zip"
        vendorUrl = "https://googletest.googlecode.com/files/$archiveName"
        explodedDirName = "gtest-${version}"
        targetPlatforms = ['osx-x86_64', 'linux-amd64', 'android-arm']

        configForPlatform = [
            'osx-x86_64': 'x86_64-apple-darwin13.0.0',
            'linux-amd64': 'x86_64-pc-linux',
            'android-arm': 'arm-linux-androideabi',
            ]

        configureCommandLine = [
            "./configure",
            "--prefix=${-> platformInstallDir}",
            "--host=${-> configForPlatform[platform]}",
            "--build=${-> currentPlatform}",
            "--disable-shared",
            "--enable-static",
            ]

        assembleCommandLine = [
            'make',
            'all',
            'install-libLTLIBRARIES',
            'install-pkgincludeHEADERS',
            'install-pkginclude_internalHEADERS',
            ]
    }
}

project(':gmock') {
    version = '1.7.0'

    ext {
        archiveName = "gmock-${version}.zip"
        vendorUrl = "https://googlemock.googlecode.com/files/$archiveName"
        explodedDirName = "gmock-${version}"
        targetPlatforms = ['osx-x86_64', 'linux-amd64', 'android-arm']

        configForPlatform = [
            'osx-x86_64': 'x86_64-apple-darwin13.0.0',
            'linux-amd64': 'x86_64-pc-linux',
            'android-arm': 'arm-linux-androideabi',
            ]

        configureCommandLine = [
            "./configure",
            "--prefix=${-> platformInstallDir}",
            "--host=${-> configForPlatform[platform]}",
            "--build=${-> currentPlatform}",
            "--disable-shared",
            "--enable-static",
            ]

        assembleCommandLine = [
            'make',
            'all',
            'install-libLTLIBRARIES',
            'install-pkgincludeHEADERS',
            'install-pkginclude_internalHEADERS',
            ]
    }
}

// apply the following to all subprojects in settings.gradle
// using the values specified above
subprojects {
    apply plugin: 'cpp'
    apply plugin: 'ivy-publish'

    group = 'com.github.opencash.vendor'

    repositories {
        ivy {
            url localIvyRepoUri
        }
    }

    publishing {
        repositories {
            ivy {
                url localIvyRepoUri
            }
        }
    }

    task testResolveDependencies << {
        println "Testing dependency resolution"
        configurations.each { conf ->
            println "=> $conf:"
            conf.files.each { println "   -> $it" }
        }
    }

    task download(type: Download) {
        outputs.files file("$buildDir/$archiveName")
        src vendorUrl
        dest buildDir
        overwrite false
    }

    targetPlatforms.each {
        ext.platform = it
        ext.platformDir = file("$buildDir/$platform")
        ext.platformSrcDir = file("$platformDir/$explodedDirName")
        ext.platformInstallDir = file("$platformDir/install")
        ext.platformDepsDir = file("$platformDir/deps")

        if (false) { // !gccExists(platform)) {
            def compiler = getGcc(platform)
            logger.info("==============")
            logger.info("Configuring build for platform '$platform':")
            logger.info("Cross-compiling but could not find '$compiler'.")
            logger.info("Please add your cross-compilation toolchain"
                        + " to your \$PATH")
            logger.info("Skipping platform '$platform'")
            logger.info("==============")
            return
        }

        def platformConf = configurations.create "compile-$platform"
        if (project.hasProperty('narDependencies')) {
            narDependencies['all'].each {
                dependencies.add "compile-$platform", it
            }
            narDependencies[platform].each {
                dependencies.add "compile-$platform", it
            }
        }

        task("unarchive-$platform", dependsOn: download) {
            inputs.files download.outputs.files.singleFile
            // Bind scope of platformSrcDir
            def platSrcDir = platformSrcDir
            outputs.upToDateWhen { platSrcDir.exists() }

            // A task of type Copy would mess with outputs field and hence
            // confuse upToDateWhen, so we use a separate closure. By doing
            // that, platformDir gets evaluated at runtime and usually doesn't
            // correspond to the value of platform anymore. We bind the scope
            // of platformDir through use of an intermediate variable
            def destDir = platformDir
            doLast {
                copy {
                    def f = download.outputs.files.singleFile
                    def t = f.name.endsWith('.zip') ?
                        zipTree(f) : tarTree(f)

                    from t
                    into destDir
                }
            }
        }

        task("patch-$platform", dependsOn: "unarchive-$platform") {
            outputs.files file("$platformSrcDir/.patched")

            fileTree(file("$projectDir/patches")).include('**/*.patch').each { File file ->
                // Bind scope of platformSrcDir
                def destDir = platformSrcDir
                doLast {
                    exec {
                        logging.captureStandardOutput LogLevel.INFO
                        logging.captureStandardError LogLevel.INFO

                        workingDir destDir
                        commandLine 'patch', '--strip=1', '--batch',
                            '--forward', "--input=$file", '--verbose'
                    }
                }
                doLast {
                    new File("$destDir/.patched").createNewFile()
                }
            }
        }

        task("retrieveDependencies-$platform", type: Copy) {
            from platformConf
            into platformDepsDir

            platformConf.incoming.afterResolve { ResolvableDependencies incoming ->
                incoming.files.each { File file ->
                    if (file.name.endsWith(".nar")) {
                        from zipTree(file)
                    }
                }
            }
        }

        task("configure-$platform", type: Exec,
                dependsOn: ["unarchive-$platform",
                    "patch-$platform",
                    "retrieveDependencies-$platform"])
        {
            // Evaluate lazy GString to interpolate current
            // project values
            def cmdLine = configureCommandLine*.toString()

            logging.captureStandardOutput LogLevel.INFO
            logging.captureStandardError LogLevel.INFO

            workingDir platformSrcDir
            commandLine cmdLine

            // Cannot use the following since some projects already come
            // with a Makefile. Couldn't find a consistent choice across
            // projects, thus commenting out. The downside is that the
            // configure step will run on every build, which is acceptable
            // since builds run rarely (only on upstream changes).
            // outputs.files file("$platformSrcDir/Makefile")
        }

        task("assemble-$platform", type: Exec,
                dependsOn: "configure-$platform")
        {
            logging.captureStandardOutput LogLevel.INFO
            logging.captureStandardError LogLevel.INFO

            workingDir platformSrcDir

            if (project.hasProperty('assembleCommandLine')) {
                commandLine assembleCommandLine
            } else {
                commandLine 'make', 'all', 'install'
            }
        }

        def platformPackage = task("package-$platform", type: Zip) {
            dependsOn "assemble-$platform"
            from platformInstallDir

            baseName project.name
            version version
            classifier platform
            extension 'nar'
        }

        publishing {
            publications {
                def p = findByName(project.name)
                if (p == null) {
                    p = create(project.name, IvyPublication)
                }
                p.artifact platformPackage
            }
        }
    }

}

def getCurrentPlatform() {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'gcc', '-dumpmachine'
        standardOutput = stdout
    }
    stdout.toString().trim()
}

def getGcc(platform) {
    def compiler = "g++"
    if (platform != currentPlatform) {
        compiler = "$platform-$compiler"
    }
    return compiler
}

def gccExists(platform) {
    def compiler = getGcc(platform)
    def stdout = new ByteArrayOutputStream()
    def findCompiler = exec {
        commandLine 'which', "$compiler"
        ignoreExitValue true
        standardOutput = stdout
    }
    findCompiler.exitValue == 0
}
